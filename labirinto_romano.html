<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labirinto Romano - Trebula Mutuesca</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: #ffd700;
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .info-panel {
            background: linear-gradient(135deg, #fff9e6 0%, #ffe4b3 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border: 3px solid #ffd700;
            text-align: center;
        }

        .info-panel p {
            color: #555;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .difficulty-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .difficulty-btn {
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        .info-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .info-label {
            color: #667eea;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .info-value {
            color: #333;
            font-size: 1.5em;
            font-weight: bold;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        #maze {
            display: inline-grid;
            gap: 2px;
            background: #333;
            padding: 2px;
            border-radius: 8px;
        }

        .cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            transition: background-color 0.3s;
            position: relative;
        }

        .cell.wall {
            background: #8B4513;
        }

        .cell.path {
            background: #F5DEB3;
        }

        .cell.start {
            background: #90EE90;
        }

        .cell.end {
            background: #FFD700;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .cell.player {
            background: #87CEEB;
        }

        .cell.visited {
            background: #E8F5E8;
        }

        .cell.coin {
            background: #FFF8DC;
        }

        .controls-help {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            text-align: center;
        }

        .controls-help h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .key-hints {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .key-hint {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f0f4ff;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .key {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* Mobile controls */
        .mobile-controls {
            display: none;
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
            
            .cell {
                width: 20px;
                height: 20px;
                font-size: 1em;
            }
        }

        .mobile-btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 0 auto;
        }

        .mobile-btn {
            padding: 20px;
            font-size: 1.5em;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mobile-btn:active {
            transform: scale(0.95);
            background: #5568d3;
        }

        .mobile-btn.empty {
            opacity: 0;
            pointer-events: none;
        }

        /* Victory modal */
        .victory-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .victory-overlay.show {
            display: flex;
        }

        .victory-message {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            animation: bounceIn 0.6s;
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .trophy {
            font-size: 5em;
            margin-bottom: 20px;
        }

        .victory-message h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .victory-stats {
            background: #f0f4ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .victory-stats p {
            margin: 10px 0;
            font-size: 1.1em;
        }

        .play-again-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .play-again-btn:hover {
            transform: scale(1.1);
        }

        /* Fumetti */
        .speech-bubble {
            position: fixed;
            background: white;
            border: 3px solid #667eea;
            border-radius: 20px;
            padding: 15px 20px;
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 999;
            animation: bounceIn 0.5s, float 2s ease-in-out infinite;
            max-width: 250px;
            pointer-events: none;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 15px solid white;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .speech-bubble::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 18px solid #667eea;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes bounceOut {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.3);
                opacity: 0;
            }
        }

        .speech-bubble.success {
            background: linear-gradient(135deg, #d4fc79 0%, #96e6a1 100%);
            border-color: #4ade80;
        }

        .speech-bubble.success::after {
            border-top-color: #96e6a1;
        }

        .speech-bubble.success::before {
            border-top-color: #4ade80;
        }

        .speech-bubble.hint {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-color: #f39c12;
        }

        .speech-bubble.hint::after {
            border-top-color: #fdcb6e;
        }

        .speech-bubble.hint::before {
            border-top-color: #f39c12;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß© Labirinto Romano</h1>
        <p class="subtitle">Attraversa le rovine di Trebula Mutuesca!</p>

        <div class="info-panel">
            <p>üèõÔ∏è Guida l'esploratore attraverso le rovine romane! Usa le frecce della tastiera o i pulsanti touch per muoverti.</p>
            <p style="margin-top: 10px;">
                ü™ô <strong>Monete</strong> = Punti bonus | 
                üíÄ <strong>Trappole</strong> = +10 secondi | 
                üî¶ <strong>Torce</strong> = Power-up speciale
            </p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>üéØ Difficolt√†:</label>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn active" data-level="easy">üòä Facile<br>Trova il Foro üèõÔ∏è</button>
                    <button class="difficulty-btn" data-level="medium">ü§î Medio<br>Le Terme üõÅ</button>
                    <button class="difficulty-btn" data-level="hard">üß† Difficile<br>Il Tesoro üëë</button>
                </div>
            </div>

            <div class="control-group">
                <button id="startBtn">üéÆ Genera Nuovo Labirinto!</button>
            </div>
        </div>

        <div class="info-bar">
            <div class="info-card">
                <div class="info-label">‚è±Ô∏è Tempo</div>
                <div class="info-value" id="timer">00:00</div>
            </div>
            <div class="info-card">
                <div class="info-label">üë£ Passi</div>
                <div class="info-value" id="steps">0</div>
            </div>
            <div class="info-card">
                <div class="info-label">ü™ô Monete</div>
                <div class="info-value" id="coins">0/0</div>
            </div>
        </div>

        <div class="controls-help">
            <h3>‚å®Ô∏è Controlli</h3>
            <div class="key-hints">
                <div class="key-hint">
                    <span class="key">‚Üë</span>
                    <span>Su</span>
                </div>
                <div class="key-hint">
                    <span class="key">‚Üê</span>
                    <span>Sinistra</span>
                </div>
                <div class="key-hint">
                    <span class="key">‚Üì</span>
                    <span>Gi√π</span>
                </div>
                <div class="key-hint">
                    <span class="key">‚Üí</span>
                    <span>Destra</span>
                </div>
            </div>
        </div>

        <div class="mobile-controls">
            <h3 style="color: #667eea; text-align: center; margin-bottom: 15px;">üì± Controlli Touch</h3>
            <div class="mobile-btn-grid">
                <div class="mobile-btn empty"></div>
                <button class="mobile-btn" onclick="movePlayer('up')">‚Üë</button>
                <div class="mobile-btn empty"></div>
                <button class="mobile-btn" onclick="movePlayer('left')">‚Üê</button>
                <div class="mobile-btn empty"></div>
                <button class="mobile-btn" onclick="movePlayer('right')">‚Üí</button>
                <div class="mobile-btn empty"></div>
                <button class="mobile-btn" onclick="movePlayer('down')">‚Üì</button>
                <div class="mobile-btn empty"></div>
            </div>
        </div>

        <div class="game-container">
            <div id="maze"></div>
        </div>
    </div>

    <div class="victory-overlay" id="victoryOverlay">
        <div class="victory-message">
            <div class="trophy">üèÜ</div>
            <h2>Obiettivo Raggiunto!</h2>
            <p style="font-size: 1.2em; color: #666; margin-bottom: 20px;">
                Hai attraversato le rovine romane!
            </p>
            <div class="victory-stats">
                <p><strong>‚è±Ô∏è Tempo:</strong> <span id="finalTime"></span></p>
                <p><strong>üë£ Passi:</strong> <span id="finalSteps"></span></p>
                <p><strong>ü™ô Monete:</strong> <span id="finalCoins"></span></p>
                <p><strong>üéØ Difficolt√†:</strong> <span id="finalDifficulty"></span></p>
            </div>
            <button class="play-again-btn" onclick="closeVictory()">üéÆ Nuovo Labirinto!</button>
        </div>
    </div>

    <script>
        let difficulty = 'easy';
        let gridSize = 8;
        let maze = [];
        let playerPos = {x: 0, y: 0};
        let endPos = {x: 0, y: 0};
        let coins = [];
        let collectedCoins = 0;
        let traps = [];
        let powerUps = [];
        let hasPowerUp = false;
        let steps = 0;
        let timerInterval;
        let seconds = 0;
        let lastSpeechBubbleTime = 0;
        let gameActive = false;

        const difficultySettings = {
            easy: {size: 15, emoji: 'üèõÔ∏è', name: 'Facile - Foro Romano', wallDensity: 0.3},
            medium: {size: 21, emoji: 'üõÅ', name: 'Medio - Terme Romane', wallDensity: 0.35},
            hard: {size: 27, emoji: 'üëë', name: 'Difficile - Tesoro Romano', wallDensity: 0.4}
        };

        const speechMessages = {
            start: [
                "üèõÔ∏è Usa le frecce per muoverti!",
                "üß≠ Trova la via d'uscita!",
                "üí´ Buona fortuna!"
            ],
            coin: [
                "ü™ô Moneta raccolta!",
                "‚ú® Ottimo!",
                "üí∞ Bene!"
            ],
            progress: [
                "üëç Stai andando bene!",
                "üéØ Continua cos√¨!",
                "üí™ Bravo!"
            ],
            nearEnd: [
                "üéØ Ci sei quasi!",
                "üèõÔ∏è L'obiettivo √® vicino!",
                "üöÄ Ancora un po'!"
            ]
        };

        // Elementi DOM
        const startBtn = document.getElementById('startBtn');
        const mazeEl = document.getElementById('maze');
        const timerDisplay = document.getElementById('timer');
        const stepsDisplay = document.getElementById('steps');
        const coinsDisplay = document.getElementById('coins');
        const victoryOverlay = document.getElementById('victoryOverlay');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');

        // Event listeners
        difficultyButtons.forEach(btn => {
            btn.addEventListener('click', function() {
                difficultyButtons.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                difficulty = this.dataset.level;
                gridSize = difficultySettings[difficulty].size;
            });
        });

        startBtn.addEventListener('click', startGame);

        document.addEventListener('keydown', handleKeyPress);

        function startGame() {
            // Reset
            steps = 0;
            collectedCoins = 0;
            seconds = 0;
            gameActive = true;
            hasPowerUp = false;
            
            clearInterval(timerInterval);
            updateTimer();
            updateSteps();
            
            // Genera labirinto
            generateMaze();
            
            // Avvia timer
            timerInterval = setInterval(() => {
                seconds++;
                updateTimer();
            }, 1000);
            
            // Fumetto iniziale
            setTimeout(() => {
                showSpeechBubble(getRandomMessage('start'), 'normal', 2500);
            }, 500);
        }

        function generateMaze() {
            gridSize = difficultySettings[difficulty].size;
            const wallDensity = difficultySettings[difficulty].wallDensity;
            maze = [];
            
            // Inizializza griglia vuota (tutti percorsi)
            for (let y = 0; y < gridSize; y++) {
                maze[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    maze[y][x] = 0; // 0 = percorso
                }
            }
            
            // Crea bordo esterno
            for (let i = 0; i < gridSize; i++) {
                maze[0][i] = 1;
                maze[gridSize-1][i] = 1;
                maze[i][0] = 1;
                maze[i][gridSize-1] = 1;
            }
            
            // Posizioni sicure per inizio e fine (angoli opposti)
            playerPos = {x: 1, y: 1};
            endPos = {x: gridSize - 2, y: gridSize - 2};
            
            // Aggiungi muri casuali ma lascia sempre un percorso
            addRandomWalls(wallDensity);
            
            // Verifica che esista un percorso con BFS
            if (!pathExists(playerPos, endPos)) {
                // Se non esiste, rigenera
                generateMaze();
                return;
            }
            
            // Aggiungi monete
            addCoins();
            
            // Renderizza
            renderMaze();
            updateCoins();
        }

        function addRandomWalls(density) {
            // Aggiungi muri casuali
            for (let y = 2; y < gridSize - 2; y++) {
                for (let x = 2; x < gridSize - 2; x++) {
                    // Non mettere muri vicino a inizio e fine
                    if ((Math.abs(x - playerPos.x) < 2 && Math.abs(y - playerPos.y) < 2) ||
                        (Math.abs(x - endPos.x) < 2 && Math.abs(y - endPos.y) < 2)) {
                        continue;
                    }
                    
                    if (Math.random() < density) {
                        maze[y][x] = 1;
                    }
                }
            }
            
            // Aggiungi alcune "stanze" (aree senza muri)
            const numRooms = Math.floor(gridSize / 8);
            for (let i = 0; i < numRooms; i++) {
                const roomX = Math.floor(Math.random() * (gridSize - 8)) + 4;
                const roomY = Math.floor(Math.random() * (gridSize - 8)) + 4;
                const roomSize = 3 + Math.floor(Math.random() * 3);
                
                for (let y = roomY; y < Math.min(roomY + roomSize, gridSize - 2); y++) {
                    for (let x = roomX; x < Math.min(roomX + roomSize, gridSize - 2); x++) {
                        maze[y][x] = 0;
                    }
                }
            }
        }

        function pathExists(start, end) {
            // BFS per verificare se esiste un percorso
            const visited = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            const queue = [{x: start.x, y: start.y}];
            visited[start.y][start.x] = true;
            
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.x === end.x && current.y === end.y) {
                    return true;
                }
                
                for (let dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize &&
                        !visited[ny][nx] && maze[ny][nx] === 0) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny});
                    }
                }
            }
            
            return false;
        }

        function addCoins() {
            coins = [];
            traps = [];
            powerUps = [];
            
            const numCoins = Math.floor(gridSize / 2);
            const numTraps = Math.floor(gridSize / 4);
            const numPowerUps = 2;
            
            // Aggiungi monete
            let added = 0;
            while (added < numCoins) {
                const x = Math.floor(Math.random() * (gridSize - 2)) + 1;
                const y = Math.floor(Math.random() * (gridSize - 2)) + 1;
                
                if (isValidItemPosition(x, y)) {
                    coins.push({x, y, collected: false});
                    added++;
                }
            }
            
            // Aggiungi trappole (riducono tempo)
            added = 0;
            while (added < numTraps) {
                const x = Math.floor(Math.random() * (gridSize - 2)) + 1;
                const y = Math.floor(Math.random() * (gridSize - 2)) + 1;
                
                if (isValidItemPosition(x, y)) {
                    traps.push({x, y, triggered: false});
                    added++;
                }
            }
            
            // Aggiungi power-up (torcia per vedere meglio)
            added = 0;
            while (added < numPowerUps) {
                const x = Math.floor(Math.random() * (gridSize - 2)) + 1;
                const y = Math.floor(Math.random() * (gridSize - 2)) + 1;
                
                if (isValidItemPosition(x, y)) {
                    powerUps.push({x, y, collected: false});
                    added++;
                }
            }
        }
        
        function isValidItemPosition(x, y) {
            // Controlla che la posizione sia valida per un oggetto
            if (maze[y][x] !== 0) return false;
            if (x === playerPos.x && y === playerPos.y) return false;
            if (x === endPos.x && y === endPos.y) return false;
            
            // Controlla che non ci siano gi√† altri oggetti
            if (coins.some(c => c.x === x && c.y === y)) return false;
            if (traps.some(t => t.x === x && t.y === y)) return false;
            if (powerUps.some(p => p.x === x && p.y === y)) return false;
            
            return true;
        }

        function renderMaze() {
            mazeEl.innerHTML = '';
            mazeEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    if (x === playerPos.x && y === playerPos.y) {
                        cell.classList.add('player');
                        cell.textContent = 'üö∂';
                    } else if (x === endPos.x && y === endPos.y) {
                        cell.classList.add('end');
                        cell.textContent = difficultySettings[difficulty].emoji;
                    } else if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    } else {
                        cell.classList.add('path');
                        
                        // Controlla oggetti
                        const coin = coins.find(c => c.x === x && c.y === y);
                        if (coin && !coin.collected) {
                            cell.classList.add('coin');
                            cell.textContent = 'ü™ô';
                        }
                        
                        const trap = traps.find(t => t.x === x && t.y === y);
                        if (trap && !trap.triggered) {
                            cell.textContent = 'üíÄ';
                            cell.style.background = '#FFE4E1';
                        }
                        
                        const powerUp = powerUps.find(p => p.x === x && p.y === y);
                        if (powerUp && !powerUp.collected) {
                            cell.textContent = 'üî¶';
                            cell.style.background = '#E6E6FA';
                        }
                    }
                    
                    mazeEl.appendChild(cell);
                }
            }
        }

        function handleKeyPress(e) {
            if (!gameActive) return;
            
            const key = e.key;
            if (key === 'ArrowUp') movePlayer('up');
            else if (key === 'ArrowDown') movePlayer('down');
            else if (key === 'ArrowLeft') movePlayer('left');
            else if (key === 'ArrowRight') movePlayer('right');
        }

        function movePlayer(direction) {
            if (!gameActive) return;
            
            let newX = playerPos.x;
            let newY = playerPos.y;
            
            if (direction === 'up') newY--;
            else if (direction === 'down') newY++;
            else if (direction === 'left') newX--;
            else if (direction === 'right') newX++;
            
            // Verifica validit√† mossa
            if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) return;
            if (maze[newY][newX] === 1) return;
            
            // Muovi
            playerPos.x = newX;
            playerPos.y = newY;
            steps++;
            updateSteps();
            
            // Controlla moneta
            const coin = coins.find(c => c.x === newX && c.y === newY);
            if (coin && !coin.collected) {
                coin.collected = true;
                collectedCoins++;
                updateCoins();
                showSpeechBubble(getRandomMessage('coin'), 'success', 1500);
            }
            
            // Controlla trappola
            const trap = traps.find(t => t.x === newX && t.y === newY);
            if (trap && !trap.triggered) {
                trap.triggered = true;
                seconds += 10; // Penalit√† di 10 secondi
                showSpeechBubble('üíÄ Trappola! +10 secondi!', 'hint', 2000);
            }
            
            // Controlla power-up
            const powerUp = powerUps.find(p => p.x === newX && p.y === newY);
            if (powerUp && !powerUp.collected) {
                powerUp.collected = true;
                hasPowerUp = true;
                showSpeechBubble('üî¶ Torcia trovata! Vedi meglio!', 'success', 2000);
            }
            
            // Feedback progresso
            if (steps % 15 === 0 && steps > 0) {
                const distance = Math.abs(endPos.x - playerPos.x) + Math.abs(endPos.y - playerPos.y);
                if (distance < 8) {
                    showSpeechBubble(getRandomMessage('nearEnd'), 'hint', 2000);
                } else if (steps % 30 === 0) {
                    showSpeechBubble(getRandomMessage('progress'), 'normal', 1500);
                }
            }
            
            renderMaze();
            
            // Controlla vittoria
            if (newX === endPos.x && newY === endPos.y) {
                gameWon();
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function updateTimer() {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            timerDisplay.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateSteps() {
            stepsDisplay.textContent = steps;
        }

        function updateCoins() {
            coinsDisplay.textContent = `${collectedCoins}/${coins.length}`;
        }

        function gameWon() {
            gameActive = false;
            clearInterval(timerInterval);
            
            document.getElementById('finalTime').textContent = timerDisplay.textContent;
            document.getElementById('finalSteps').textContent = steps;
            document.getElementById('finalCoins').textContent = `${collectedCoins}/${coins.length}`;
            document.getElementById('finalDifficulty').textContent = difficultySettings[difficulty].name;
            
            victoryOverlay.classList.add('show');
        }

        function closeVictory() {
            victoryOverlay.classList.remove('show');
            startGame();
        }

        function showSpeechBubble(message, type = 'normal', duration = 2000) {
            const now = Date.now();
            if (now - lastSpeechBubbleTime < 500) return;
            lastSpeechBubbleTime = now;

            const existingBubbles = document.querySelectorAll('.speech-bubble');
            existingBubbles.forEach(b => b.remove());

            const bubble = document.createElement('div');
            bubble.className = `speech-bubble ${type}`;
            bubble.textContent = message;

            const positions = [
                { top: '15%', left: '10%' },
                { top: '15%', right: '10%' },
                { top: '40%', left: '5%' },
                { top: '40%', right: '5%' }
            ];
            const pos = positions[Math.floor(Math.random() * positions.length)];
            Object.assign(bubble.style, pos);

            document.body.appendChild(bubble);

            setTimeout(() => {
                bubble.style.animation = 'bounceOut 0.5s';
                setTimeout(() => bubble.remove(), 500);
            }, duration);
        }

        function getRandomMessage(category) {
            const messages = speechMessages[category];
            return messages[Math.floor(Math.random() * messages.length)];
        }
    </script>
</body>
</html>
